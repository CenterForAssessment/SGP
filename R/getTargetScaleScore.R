`getTargetScaleScore` <- 
function(sgp_object,
	state,
	sgp.targets,
	target.type,
	target.level,
	tmp.years.content_areas.grades,
	parallel.config=NULL) {

	VALID_CASE <- ID <- CONTENT_AREA <- YEAR <- GRADE <- YEAR_WITHIN <- NULL

	### Utility functions

	tmp_sgp_object <- list(Coefficient_Matrices=sgp_object@SGP[["Coefficient_Matrices"]], Knots_Boundaries=sgp_object@SGP[["Knots_Boundaries"]])
	setkey(sgp_object@Data, VALID_CASE, ID)
	variables.to.get <- c("VALID_CASE", "YEAR", "CONTENT_AREA", "GRADE", "ID", "SCALE_SCORE", "YEAR_WITHIN", "FIRST_OBSERVATION", "LAST_OBSERVATION")
	tmp_sgp_data_for_analysis <- sgp_object@Data[SJ("VALID_CASE", unique(sgp.targets[['ID']]))][, intersect(names(sgp_object@Data), variables.to.get), with=FALSE]
        if ("YEAR_WITHIN" %in% names(tmp_sgp_data_for_analysis)) {
                setkey(tmp_sgp_data_for_analysis, VALID_CASE, CONTENT_AREA, YEAR, GRADE, YEAR_WITHIN)
        } else {
                setkey(tmp_sgp_data_for_analysis, VALID_CASE, CONTENT_AREA, YEAR, GRADE)
        }
	setkeyv(sgp_object@Data, getKey(sgp_object))
	
	par.sgp.config <- getSGPConfig(
				sgp_object,
				tmp_sgp_object,
				sort(unique(tmp.years.content_areas.grades[['CONTENT_AREA']])),
				sort(unique(tmp.years.content_areas.grades[['YEAR']])),
				sort(unique(tmp.years.content_areas.grades[['GRADE']])),
				sgp.config=NULL,
				sgp.percentiles=TRUE,
				sgp.projections=TRUE,
				sgp.projections.lagged=TRUE,
				sgp.percentiles.baseline=length(grep("baseline", target.type)) > 0,
				sgp.projections.baseline=length(grep("baseline", target.type)) > 0,
				sgp.projections.lagged.baseline=length(grep("baseline", target.type)) > 0,
				sgp.config.drop.nonsequential.grade.progression.variables=FALSE)

	### Define variables

	if (target.type=="sgp.projections") {
		my.extra.label <- "TARGET_SCALE_SCORES"
		baseline.tf <- FALSE
		lag.increment <- 0
		my.target.type <- "sgp.projections"
	}
	if (target.type=="sgp.projections.baseline") {
		my.extra.label <- "BASELINE.TARGET_SCALE_SCORES"
		baseline.tf <- TRUE
		lag.increment <- 0
		my.target.type <- "sgp.projections"
	}
	if (target.type=="sgp.projections.lagged") {
		my.extra.label <- "LAGGED.TARGET_SCALE_SCORES"
		baseline.tf <- FALSE
		lag.increment <- 1
		my.target.type <- "sgp.projections.lagged"
	}

	if (target.type=="sgp.projections.lagged.baseline") {
		my.extra.label <- "LAGGED.BASELINE.TARGET_SCALE_SCORES"
		baseline.tf <- TRUE
		lag.increment <- 1
		my.target.type <- "sgp.projections.lagged"
	}



	### Calculate targets

	if (!is.null(parallel.config) && parallel.config[["WORKERS"]][["SGP_SCALE_SCORE_TARGETS"]] > 1) {
		par.start <- startParallel(parallel.config, 'SGP_SCALE_SCORE_TARGETS')
		
		###  FOREACH flavor

		if (toupper(parallel.config[["BACKEND"]]) == "FOREACH") {
			tmp <- foreach(sgp.iter=iter(par.sgp.config), .packages="SGP", .combine="mergeSGP", .inorder=FALSE,
				.options.multicore=par.start$foreach.options, .options.mpi=par.start$foreach.options, .options.redis=par.start$foreach.options) %dopar% {
				return(studentGrowthProjections(
					panel.data=list(Panel_Data=getPanelData(tmp_sgp_data_for_analysis, my.target.type, sgp.iter, sgp.targets), 
						Coefficient_Matrices=tmp_sgp_object[["Coefficient_Matrices"]], Knots_Boundaries=getKnotsBoundaries(sgp.iter, state)),
					sgp.labels=list(my.year=tail(sgp.iter[["sgp.panel.years"]], 1), my.subject=tail(sgp.iter[["sgp.content.areas"]], 1), 
						my.extra.label=my.extra.label),
					use.my.coefficient.matrices=list(my.year=if (baseline.tf) "BASELINE" else tail(sgp.iter[["sgp.panel.years"]], 1), 
						my.subject=tail(sgp.iter[["sgp.content.areas"]], 1)), 
					use.my.knots.boundaries=list(my.year=tail(sgp.iter[["sgp.panel.years"]], 1), my.subject=tail(sgp.iter[["sgp.content.areas"]], 1)),
					performance.level.cutscores=state,
					panel.data.vnames=getPanelDataVnames(my.target.type, sgp.iter),
					grade.progression=sgp.iter[["sgp.projection.grade.sequences"]],
					content_area.progression=sgp.iter[["sgp.projection.content.areas"]],
					year_lags.progression=sgp.iter[["sgp.projection.panel.years.lags"]],
					max.order.for.progression=getMaxOrderForProgression(tail(sgp.iter[["sgp.panel.years"]], 1), tail(sgp.iter[["sgp.content.areas"]], 1), state),
					lag.increment=lag.increment,
					grade.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["grade.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
					content_area.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["content_area.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
					year_lags.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["year_lags.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
					percentile.trajectory.values=target.level,
					calculate.sgps=!(tail(sgp.iter[["sgp.panel.years"]], 1) %in% SGPstateData[[state]][["Assessment_Program_Information"]][["Scale_Change"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]]),
					projcuts.digits=SGPstateData[[state]][["SGP_Configuration"]][["projcuts.digits"]]))
			}
			tmp_sgp_object <- mergeSGP(tmp_sgp_object, tmp)
			rm(tmp)
		} else {# END FOREACH
			###   SNOW flavor
			if (par.start$par.type == 'SNOW') {
				tmp <- clusterApplyLB(par.start$internal.cl, par.sgp.config, 	function(sgp.iter)	studentGrowthProjections(
					panel.data=list(Panel_Data=getPanelData(tmp_sgp_data_for_analysis, my.target.type, sgp.iter, sgp.targets), 
						Coefficient_Matrices=tmp_sgp_object[['Coefficient_Matrices']], Knots_Boundaries=getKnotsBoundaries(sgp.iter, state)),
					sgp.labels=list(my.year=tail(sgp.iter[["sgp.panel.years"]], 1), my.subject=tail(sgp.iter[['sgp.content.areas']], 1),
						my.extra.label=my.extra.label),
					use.my.coefficient.matrices=list(my.year=if (baseline.tf) "BASELINE" else tail(sgp.iter[["sgp.panel.years"]], 1), 
						my.subject=tail(sgp.iter[["sgp.content.areas"]], 1)), 
					use.my.knots.boundaries=list(my.year=tail(sgp.iter[['sgp.panel.years']], 1), my.subject=tail(sgp.iter[['sgp.content.areas']], 1)),
					performance.level.cutscores=state,
					panel.data.vnames=getPanelDataVnames(my.target.type, sgp.iter),
					grade.progression=sgp.iter[["sgp.projection.grade.sequences"]],
					content_area.progression=sgp.iter[["sgp.projection.content.areas"]],
					year_lags.progression=sgp.iter[["sgp.projection.panel.years.lags"]],
					max.order.for.progression=getMaxOrderForProgression(tail(sgp.iter[["sgp.panel.years"]], 1), tail(sgp.iter[["sgp.content.areas"]], 1), state),
					lag.increment=lag.increment,
					grade.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["grade.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
					content_area.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["content_area.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
					year_lags.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["year_lags.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
					percentile.trajectory.values=target.level,
					calculate.sgps=!(tail(sgp.iter[['sgp.panel.years']], 1) %in% SGPstateData[[state]][['Assessment_Program_Information']][['Scale_Change']][[tail(sgp.iter[['sgp.content.areas']], 1)]]),
					projcuts.digits=SGPstateData[[state]][['SGP_Configuration']][['projcuts.digits']]))

					tmp_sgp_object <- mergeSGP(Reduce(mergeSGP, tmp), tmp_sgp_object)
					rm(tmp)
				} # END SNOW
			
				###  MULTICORE flavor
				if (par.start$par.type == 'MULTICORE') {
					tmp <- mclapply(par.sgp.config, function(sgp.iter)	studentGrowthProjections(
						panel.data=list(Panel_Data=getPanelData(tmp_sgp_data_for_analysis, my.target.type, sgp.iter, sgp.targets), 
							Coefficient_Matrices=tmp_sgp_object[["Coefficient_Matrices"]], Knots_Boundaries=getKnotsBoundaries(sgp.iter, state)),
						sgp.labels=list(my.year=tail(sgp.iter[["sgp.panel.years"]], 1), my.subject=tail(sgp.iter[["sgp.content.areas"]], 1), 
							my.extra.label=my.extra.label),
						use.my.coefficient.matrices=list(my.year=if (baseline.tf) "BASELINE" else tail(sgp.iter[["sgp.panel.years"]], 1), 
							my.subject=tail(sgp.iter[["sgp.content.areas"]], 1)), 
						use.my.knots.boundaries=list(my.year=tail(sgp.iter[["sgp.panel.years"]], 1), my.subject=tail(sgp.iter[["sgp.content.areas"]], 1)),
						performance.level.cutscores=state,
						panel.data.vnames=getPanelDataVnames(my.target.type, sgp.iter),
						grade.progression=sgp.iter[["sgp.projection.grade.sequences"]],
						content_area.progression=sgp.iter[["sgp.projection.content.areas"]],
						year_lags.progression=sgp.iter[["sgp.projection.panel.years.lags"]],
						max.order.for.progression=getMaxOrderForProgression(tail(sgp.iter[["sgp.panel.years"]], 1), tail(sgp.iter[["sgp.content.areas"]], 1), state),
						lag.increment=lag.increment,
						grade.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["grade.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
						content_area.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["content_area.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
						year_lags.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["year_lags.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
						percentile.trajectory.values=target.level,
						calculate.sgps=!(tail(sgp.iter[["sgp.panel.years"]], 1) %in% SGPstateData[[state]][["Assessment_Program_Information"]][["Scale_Change"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]]),
						projcuts.digits=SGPstateData[[state]][["SGP_Configuration"]][["projcuts.digits"]]),
						mc.cores=par.start$workers, mc.preschedule=FALSE)
	
					tmp_sgp_object <- mergeSGP(Reduce(mergeSGP, tmp), tmp_sgp_object)
					if (any(tmp.tf <- sapply(tmp, function(x) identical(class(x), "try-error")))) {
						tmp_sgp_object[['Error_Reports']] <- c(tmp_sgp_object[['Error_Reports']], sgp.projections.lagged.=getErrorReports(tmp, tmp.tf, par.sgp.config))
					}
					rm(tmp)
				} # End MULTICORE
			} # END parallel flavors
		stopParallel(parallel.config, par.start)
		suppressMessages(gc()) # clean up
	} else { ### END if (!is.null(parallel.config))

		for (sgp.iter in par.sgp.config) {
			panel.data=within(tmp_sgp_object, assign("Panel_Data", getPanelData(tmp_sgp_data_for_analysis, my.target.type, sgp.iter, sgp.targets)))
			panel.data[['Coefficient_Matrices']] <- tmp_sgp_object[['Coefficient_Matrices']]
			panel.data[['Knots_Boundaries']] <- tmp_sgp_object[['Knots_Boundaries']]
	
			tmp_sgp_object <- studentGrowthProjections(
				panel.data=panel.data,
				sgp.labels=list(my.year=tail(sgp.iter[["sgp.panel.years"]], 1), my.subject=tail(sgp.iter[["sgp.content.areas"]], 1), 
					my.extra.label=my.extra.label),
				use.my.coefficient.matrices=list(my.year=if (baseline.tf) "BASELINE" else tail(sgp.iter[["sgp.panel.years"]], 1), 
					my.subject=tail(sgp.iter[["sgp.content.areas"]], 1)), 
				use.my.knots.boundaries=list(my.year=tail(sgp.iter[["sgp.panel.years"]], 1), my.subject=tail(sgp.iter[["sgp.content.areas"]], 1)),
				performance.level.cutscores=state,
				panel.data.vnames=getPanelDataVnames(my.target.type, sgp.iter),
				grade.progression=sgp.iter[["sgp.projection.grade.sequences"]],
				content_area.progression=sgp.iter[["sgp.projection.content.areas"]],
				year_lags.progression=sgp.iter[["sgp.projection.panel.years.lags"]],
				max.order.for.progression=getMaxOrderForProgression(tail(sgp.iter[["sgp.panel.years"]], 1), tail(sgp.iter[["sgp.content.areas"]], 1), state),
				lag.increment=lag.increment,
				grade.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["grade.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
				content_area.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["content_area.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
				year_lags.projection.sequence=SGPstateData[[state]][["SGP_Configuration"]][["year_lags.projection.sequence"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]],
				percentile.trajectory.values=target.level,
				calculate.sgps=!(tail(sgp.iter[["sgp.panel.years"]], 1) %in% SGPstateData[[state]][["Assessment_Program_Information"]][["Scale_Change"]][[tail(sgp.iter[["sgp.content.areas"]], 1)]]),
				projcuts.digits=SGPstateData[[state]][["SGP_Configuration"]][["projcuts.digits"]])
		}
	} ### END if (is.null(parallel.config))

	sgp_object@SGP <- mergeSGP(tmp_sgp_object, sgp_object@SGP)
	return(sgp_object)

} ### END getTargetScaleScore
